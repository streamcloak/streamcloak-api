import datetime
import json
import socket
from pathlib import Path
from typing import Any, Dict, List

from app.core.logger import logger
from app.core.utils import run_command

TRACKER_FILE = Path("/tmp/client_history.json")
IW_PATH = "/usr/sbin/iw"


class ClientService:
    @staticmethod
    def _convert_seconds(seconds: int | float) -> str:
        """Converts seconds into a readable string (e.g. 1h 20m)."""
        if seconds is None:
            return "-"
        return str(datetime.timedelta(seconds=int(seconds)))

    @staticmethod
    def _get_hostname(ip_address: str) -> str | None:
        """Performs a reverse DNS lookup with a short timeout."""
        if not ip_address or ip_address == "-":
            return "-"
        try:
            # Short timeout to prevent blocking the API if DNS is unresponsive
            socket.setdefaulttimeout(0.2)
            return socket.gethostbyaddr(ip_address)[0]
        except Exception as e:
            logger.warning(f"Cannot get hostname: {e}")
            return None

    @staticmethod
    def _get_wifi_stations_raw() -> Dict[str, Dict[str, Any]]:
        """
        Executes 'iw' command to get live WiFi station layer 2 data.
        Requires appropriate permissions (root or cap_net_admin).
        """
        return_code, stdout, _ = run_command([IW_PATH, "dev", "wlan0", "station", "dump"])

        if return_code != 0:
            # Logging is already handled inside run_command
            return {}

        wifi_data = {}
        current_mac = None

        for line in stdout.splitlines():
            line = line.strip()
            if line.startswith("Station"):
                current_mac = line.split()[1]
                wifi_data[current_mac] = {"mac": current_mac, "connected_time": 0, "tx_bitrate": "-"}
            elif current_mac and line.startswith("connected time:"):
                parts = line.split(":")
                if len(parts) > 1:
                    wifi_data[current_mac]["connected_time"] = int(parts[1].strip().split()[0])
            elif current_mac and line.startswith("tx bitrate:"):
                # Safety check for split
                parts = line.split(":")
                if len(parts) > 1:
                    wifi_data[current_mac]["tx_bitrate"] = parts[1].strip()

        return wifi_data

    @staticmethod
    def _get_tracker_history() -> Dict[str, Any]:
        """Reads the JSON history file generated by the background network sniffer."""
        if not TRACKER_FILE.exists():
            return {}
        try:
            with open(TRACKER_FILE, "r") as f:
                return json.load(f)
        except Exception as e:
            logger.warning(f"Cannot get tracker history: {e}")
            return {}

    def get_all_clients(self) -> List[Dict[str, Any]]:
        """
        Merges Layer 2 WiFi data with Layer 3 IP tracker history.
        Returns a flat list of clients compliant with the schema.
        """
        now = datetime.datetime.now()
        current_ts = int(now.timestamp())

        # 1. Fetch raw data
        wifi_data = self._get_wifi_stations_raw()
        history = self._get_tracker_history()

        final_clients_map = {}

        # 2. Process History (IP/Gateway/IPTV context)
        for _, data in history.items():
            mac = data.get("mac")
            ip = data.get("ip")

            # Prefer MAC as primary key
            id_key = mac if mac else ip

            last_seen = data.get("last_seen", 0)
            first_seen = data.get("first_seen", last_seen or current_ts)

            online_diff = current_ts - last_seen
            conn_diff = current_ts - first_seen

            # Fallback connection time if not overriden by WiFi later
            conn_time_str = self._convert_seconds(conn_diff) if conn_diff < 86400 else "> 1d"

            final_clients_map[id_key] = {
                "device_ip": ip,
                "device_mac": mac or "",
                "hostname": data.get("hostname") or self._get_hostname(ip),
                "connection_time": conn_time_str,
                "wifi": False,
                "gateway": "gateway" in data.get("types", []),
                "iptv": "iptv" in data.get("types", []),
                # internal flag for sorting
                "_is_online": online_diff < 120,
            }

        # 3. Merge WiFi Data (L2 Context, higher precision for time)
        for mac, wf_info in wifi_data.items():
            if mac in final_clients_map:
                final_clients_map[mac]["wifi"] = True
                final_clients_map[mac]["connection_time"] = self._convert_seconds(wf_info["connected_time"])
                final_clients_map[mac]["_is_online"] = True
            else:
                # Device is on WiFi but hasn't sent IP traffic yet (ARP/DHCP pending)
                final_clients_map[mac] = {
                    "device_ip": "-",
                    "device_mac": mac,
                    "hostname": "",
                    "connection_time": self._convert_seconds(wf_info["connected_time"]),
                    "wifi": True,
                    "gateway": False,
                    "iptv": False,
                    "_is_online": True,
                }

        # 4. Create List and Sort
        output_list = list(final_clients_map.values())

        # Sort: Online devices first
        output_list.sort(key=lambda x: 0 if x.get("_is_online") else 1)

        # Cleanup internal keys
        for item in output_list:
            if "_is_online" in item:
                del item["_is_online"]

        return output_list
